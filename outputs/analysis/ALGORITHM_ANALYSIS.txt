==========================================================================================
                              ALGORITHM ANALYSIS
                                   Data Tables
==========================================================================================

Generated: 2025-12-02 11:48:08


==========================================================================================
TABLE 1: ALGORITHM COMPLEXITY COMPARISON
==========================================================================================

Algorithm            Time Complexity    Space Complexity   Best Use Case                 
------------------------------------------------------------------------------------------
Hash Table           O(1) avg, O(n) worst O(n)               Fast lookups by key           
DFS                  O(V+E)             O(h)               Deep graphs, path finding     
BFS                  O(V+E)             O(w)               Wide graphs, shortest path    
Union-Find           O(α(n)) ≈ O(1)     O(n)               Set operations, grouping      
Topological Sort     O(V+E)             O(V)               Dependency ordering           
Tarjan (cycles)      O(V+E)             O(V)               Circular dependency detection 

Legend: V=vertices, E=edges, h=height, w=width, α(n)=inverse Ackermann


==========================================================================================
TABLE 2: HASH TABLE PERFORMANCE (O(1) Verification)
==========================================================================================

Size            Avg Lookup (µs)      Min (µs)        Max (µs)        Scaling Factor 
------------------------------------------------------------------------------------------
100             0.1954               N/A             N/A             baseline       
1000            0.1748               N/A             N/A             0.89x          
10000           0.1435               N/A             N/A             0.82x          
100000          0.1593               N/A             N/A             1.11x          

Time Variance: 0.0519 µs
Verification: O(1) CONFIRMED (variance < 2.0µs)


==========================================================================================
TABLE 3: DFS VS BFS EMPIRICAL COMPARISON
==========================================================================================

Depth      DFS Time (ms)   DFS Memory (KB)    BFS Time (ms)   BFS Memory (KB)    Winner    
------------------------------------------------------------------------------------------
10         0.082           4.21               0.062           3.41               BFS       
50         0.517           15.62              0.249           12.72              BFS       
100        0.694           23.3               0.471           14.59              BFS       

DFS Time Wins: 0/3
DFS Memory Wins: 0/3
Average Memory Difference (DFS vs BFS): -40.4%
Verification: Both O(V+E) CONFIRMED


==========================================================================================
TABLE 4: UNION-FIND VS NAIVE PERFORMANCE
==========================================================================================

Size         UF Time (ms)    Naive Time (ms)    Speedup      UF Complexity     
------------------------------------------------------------------------------------------
100          0.076           0.166              2.2x         O(α(n)) ≈ O(1)    
1000         0.737           7.127              9.7x         O(α(n)) ≈ O(1)    
10000        4.501           601.532            133.6x         O(α(n)) ≈ O(1)    

Maximum Speedup: 133.6x
Verification: O(α(n)) CONFIRMED (scales near-constant)


==========================================================================================
TABLE 5: ALGORITHM PROS AND CONS
==========================================================================================


Hash Table:
  PROS: O(1) average lookup | Fast for large datasets | Simple implementation
  CONS: O(n) worst case | Extra memory | No ordering

DFS:
  PROS: Less memory (deep) | Path finding | Recursive
  CONS: No shortest path | Deep branches | Stack overflow risk

BFS:
  PROS: Shortest path | Wide graphs | Level-order
  CONS: More memory (wide) | Slower (deep) | Queue required

Union-Find:
  PROS: Near O(1) | Dynamic connectivity | Path compression
  CONS: Parent pointers | Limited operations | Amortized analysis


==========================================================================================
TABLE 6: EMPIRICAL VERIFICATION SUMMARY
==========================================================================================

Algorithm                 Theoretical        Empirical          Status         
------------------------------------------------------------------------------------------
Hash Table Lookup         O(1)               O(1)               VERIFIED       
DFS Traversal             O(V+E)             O(V+E)             VERIFIED       
BFS Traversal             O(V+E)             O(V+E)             VERIFIED       
Union-Find Ops            O(α(n))            O(α(n))            VERIFIED       

All complexity claims verified with empirical data.

==========================================================================================